# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'handas.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QKeySequence
from PyQt5.QtWidgets import QShortcut, QMessageBox

from threading import Thread
import threading
import time







class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(552, 524)
        self.LIST_PD=['', '', '', '', '']
        self.LIST_XD=[]
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.centralwidget)
        self.verticalLayout.setObjectName("verticalLayout")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(12)
        self.label_2.setFont(font)
        self.label_2.setObjectName("label_2")
        self.verticalLayout_2.addWidget(self.label_2)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setSpacing(0)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.pushButton_3 = QtWidgets.QPushButton(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_3.setFont(font)
        self.pushButton_3.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        self.pushButton_3.setObjectName("pushButton_3")
        self.pushButton_3.clicked.connect(lambda: self.Btn_onc(0))
        self.horizontalLayout.addWidget(self.pushButton_3)
        self.pushButton_4 = QtWidgets.QPushButton(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_4.setFont(font)
        self.pushButton_4.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        self.pushButton_4.setObjectName("pushButton_4")
        self.pushButton_4.clicked.connect(lambda: self.Btn_onc(1))
        self.horizontalLayout.addWidget(self.pushButton_4)
        self.pushButton_5 = QtWidgets.QPushButton(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_5.setFont(font)
        self.pushButton_5.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        self.pushButton_5.setObjectName("pushButton_5")
        self.pushButton_5.clicked.connect(lambda: self.Btn_onc(2))
        self.horizontalLayout.addWidget(self.pushButton_5)
        self.pushButton_2 = QtWidgets.QPushButton(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_2.setFont(font)
        self.pushButton_2.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        self.pushButton_2.setObjectName("pushButton_2")
        self.pushButton_2.clicked.connect(lambda: self.Btn_onc(3))
        self.horizontalLayout.addWidget(self.pushButton_2)
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton.setFont(font)
        self.pushButton.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        self.pushButton.setObjectName("pushButton")
        self.pushButton.clicked.connect(lambda: self.Btn_onc(4))
        self.horizontalLayout.addWidget(self.pushButton)
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.verticalLayout_2.addLayout(self.horizontalLayout)
        self.label = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(12)
        self.label.setFont(font)
        self.label.setObjectName("label")
        self.verticalLayout_2.addWidget(self.label)
        self.textEdit = QtWidgets.QTextEdit(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.textEdit.setFont(font)
        self.textEdit.setObjectName("textEdit")
        self.textEdit.textChanged.connect(self.doSomething)
        self.verticalLayout_2.addWidget(self.textEdit)
        self.verticalLayout.addLayout(self.verticalLayout_2)
        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        self.msgSc = QShortcut(QKeySequence('Alt+1'), MainWindow)
        self.msgSc.activated.connect(lambda: self.Btn_onc(0))
        self.msgSc = QShortcut(QKeySequence('Alt+2'), MainWindow)
        self.msgSc.activated.connect(lambda: self.Btn_onc(1))
        self.msgSc = QShortcut(QKeySequence('Alt+3'), MainWindow)
        self.msgSc.activated.connect(lambda: self.Btn_onc(2))
        self.msgSc = QShortcut(QKeySequence('Alt+4'), MainWindow)
        self.msgSc.activated.connect(lambda: self.Btn_onc(3))
        self.msgSc = QShortcut(QKeySequence('Alt+5'), MainWindow)
        self.msgSc.activated.connect(lambda: self.Btn_onc(4))

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.label_2.setText(_translate("MainWindow", ""))
        self.pushButton_3.setText(_translate("MainWindow", "Gợi ý từ"))
        self.pushButton_4.setText(_translate("MainWindow", "2"))
        self.pushButton_5.setText(_translate("MainWindow", "3"))
        self.pushButton_2.setText(_translate("MainWindow", "4"))
        self.pushButton.setText(_translate("MainWindow", "5"))
        self.label.setText(_translate("MainWindow", "Nhập văn bản"))
        self.pushButton_4.hide()
        self.pushButton_5.hide()
        self.pushButton_2.hide()
        self.pushButton.hide()

    def doSomething(self):
        _translate = QtCore.QCoreApplication.translate
        text = str(self.textEdit.toPlainText())
        self.donat_TG = " ".join(text.split()[-2:])
        if text == '':
            return
        list_at = predict_next_word_in_view(str(self.textEdit.toPlainText()), 5)
        if list_at != None:
            self.pushButton_3.setStyleSheet("color :")
            self.pushButton_3.setText(_translate("MainWindow", list_at[0][0]))
            self.pushButton_4.setText(_translate("MainWindow", list_at[1][0]))
            self.pushButton_5.setText(_translate("MainWindow", list_at[2][0]))
            self.pushButton_2.setText(_translate("MainWindow", list_at[3][0]))
            self.pushButton.setText(_translate("MainWindow", list_at[4][0]))
            self.LIST_AT = list_at
            self.LIST_PD = [list_at[0][1], list_at[1][1], list_at[2][1], list_at[3][1], list_at[4][1]]
            if list_at[0][0] == "":
                self.pushButton_3.hide()
            else:
                self.pushButton_3.show()
            if list_at[1][0] == "":
                self.pushButton_4.hide()
            else:
                self.pushButton_4.show()
            if list_at[2][0] == "":
                self.pushButton_5.hide()
            else:
                self.pushButton_5.show()
            if list_at[3][0] == "":
                self.pushButton_2.hide()
            else:
                self.pushButton_2.show()
            if list_at[4][0] == "":
                self.pushButton.hide()
            else:
                self.pushButton.show()

        else:
            self.pushButton_3.setStyleSheet('color: red;}')
            try:
                if len(threading.enumerate()) == 1:
                    self.LIST_XD = []
                    self.t1 = threading.Thread(target=self.prx,  args=(str(self.textEdit.toPlainText()), 5))
                    self.t1.start()
                else:
                    self.LIST_XD.append(str(self.textEdit.toPlainText()))
            except:
                print("erol doSomething")
                pass

    def Btn_onc(self, n):
        self.textEdit.textCursor().insertText(self.LIST_PD[n])
        file = open("hata.txt", "w", encoding="utf-16")
        file.write(str(self.textEdit.toPlainText()))
        file.close()

    def on_open(self):
        print('Ctrl O has been fired')

    def prx(self, text, idx):
        try:
            if text == "":
                return
            talet = guess_word(text, idx, 2, approximately=True)
            _translate = QtCore.QCoreApplication.translate
            self.pushButton_3.setText(_translate("MainWindow", talet[0][0]))
            self.pushButton_4.setText(_translate("MainWindow", ""))
            self.pushButton_5.setText(_translate("MainWindow", ""))
            self.pushButton_2.setText(_translate("MainWindow", ""))
            self.pushButton.setText(_translate("MainWindow", ""))
            self.LIST_PD = ["", "", "", "", ""]
            self.pushButton_4.hide()
            self.pushButton_5.hide()
            self.pushButton_2.hide()
            self.pushButton.hide()
            if len(self.LIST_XD) > 0:
                self.LIST_XD = []
                self.t1 = threading.Thread(target=self.prx, args=(str(self.textEdit.toPlainText()), 5))
                self.t1.start()
        except:
            print("erol prx")
            pass

import underthesea
import random
import re

def texts_Compare_similarity(ls_text1, ls_text2):
    ata = 0
    ls_text2_t = list(ls_text2)
    bso = len(ls_text2_t)
    list_id = []
    for val in ls_text1:
        if val in ls_text2_t:
            ata += 1
            key = ls_text2_t.index(val)
            ls_text2_t[key] = "*"
            list_id.append(key)
    return [ata, bso, list_id]


def highest_probability(piece_text, piece_list):
    atast = []
    qes_ui_len = len(piece_text)
    for x in piece_list:
        piba = texts_Compare_similarity(piece_text, x)
        le_1 = 0
        le_2 = 0
        len_pi_id = len(piba[2])-1
        for key, val in enumerate(piba[2]):
            if key == len_pi_id:
                break
            if val+1 == piba[2][key+1]:
                le_1 += 1
            if val < piba[2][key+1]:
                le_2 += 1
        if piba[0] == 0:
            atast.append(0)
        else:
            atast.append((0.57*(piba[0]/piba[1]) + 0.29*(le_1/piba[0]) + 0.14*(le_2/piba[0]))*(piba[0]/qes_ui_len))
    return atast.index(max(atast))


dabile = {}

WORD_LENGTH = 2

with open('a_mod_lit_f.txt', "r", encoding="utf-16") as file:
    for line in file:
        line_t = line.split("\t", 2)
        key = line_t[0]
        if len(key.split()) > WORD_LENGTH:
            continue
        value = [line_t[1].split(","), line_t[2].replace("\n", "").split(",")]
        val_end = []
        for ind, val in enumerate(value[0]):
            val_end.append([val, value[1][ind]])
        dabile[key] = val_end

dabile_key = list(dabile.keys())
dabile_key_df = list(dabile.keys())
for ind, val in enumerate(dabile_key):
    dabile_key[ind] = list(val)

file1 = open("hata.txt", "r+", encoding="utf-16")
file2 = open("dota.txt", "a+", encoding="utf-16")
text_1 = file1.read()
text_1 = re.sub('\s+', ' ', re.sub('\W', ' ', text_1))
file2.write(" "+text_1)
file1.truncate(0)
file1.close()
file2.close()
file2 =open("dota.txt", "r", encoding="utf-16")
open("hata.txt", "r", encoding="utf-16")
text_db = file2.read()
file2.close()
# print(text_db)

def guess_word(text, net_lt, len_n=2, approximately=False):
    if text == '':
        return []
    text_cp = text[-1:]
    text_n = text.split()
    if len(text) > len_n:
        text_n = text_n[-len_n:]
    text_dp = " ".join(text_n)
    text_dp = list(text_dp.lower())
    con_c = 0
    while(len(text_n) > 0):
        text = " ".join(text_n)
        if text in dabile:
            con_c = 1
            det = [[text, con_c], dabile[text]]
            break
        det_tt = []
        for ind in dabile:
            if ind.startswith(text):
                det_tt.append([ind, 0])
                con_c = 2
                # break
        if con_c == 2:
            det = [[text, con_c], det_tt]
            break
        text_n.pop(0)
    if len(text_n) == 0:
        if not approximately:
            return []
        text_p = highest_probability(text_dp, dabile_key)
        tex_dc = dabile_key_df[text_p]
        det = [[tex_dc, con_c], dabile[tex_dc]]
        # return None
    cap_v = 0.7
    det[1].sort(key=lambda s: s[1], reverse=True)
    if len(det[1]) > net_lt:
        nat = int(net_lt*cap_v)
        det[1] = det[1][:nat] + random.choices(det[1][nat:], k=net_lt-nat)
    valueb = []
    for x in det[1]:
        valueb.append(x[0])
    det[1] = valueb
    return det


def predict_next_word(text, net_lt, len_n=2, approximately=False):
    prediction_list = []
    text_nt = text.split()[-1]
    if text_nt.isupper():
        text_nt = 1
    elif text_nt[0].isupper():
        text_nt = 2
    else:
        text_nt = 0
    prediction_op = guess_word(text.lower(), net_lt, len_n, approximately)
    if len(prediction_op) == 0:
        for i in range(net_lt):
            prediction_list.append(["", ""])
        return prediction_list
    pas = [" ", ""]
    if text[-1] == " ":
        pas = ["", " "]
    if text_nt == 2:
        prediction_op[0][0] = prediction_op[0][0].title()
        for ind, val in enumerate(prediction_op[1]):
            prediction_op[1][ind] = val.title()
    if text_nt == 1:
        prediction_op[0][0] = prediction_op[0][0].upper()
        for ind, val in enumerate(prediction_op[1]):
            prediction_op[1][ind] = val.upper()
    if prediction_op[0][1] == 1:
        for ind in prediction_op[1]:
            prediction_list.append([ind, pas[0]+ind])
    elif prediction_op[0][1] == 2:
        for ind in prediction_op[1]:
            prediction_list.append([ind, ind.replace(prediction_op[0][0], "", 1)])
    if len(prediction_list) >= net_lt:
        return prediction_list[0:net_lt]
    pre_list = prediction_op[0][0].split()
    if len(pre_list) > 1:
        pre_list.pop(0)
        prediction_list += predict_next_word(" ".join(pre_list)+pas[1], net_lt*2, len_n, approximately)
        detra = []
        detro = []
        for x in prediction_list:
            if not x[0] in detra:
                detro.append(x)
                detra.append(x[0])
        prediction_list = detro[0:net_lt]
    for i in range(net_lt - len(prediction_list)):
        prediction_list.append(["", ""])
    return prediction_list

PREDICTED_LENGTH = 5


def from_text_Next_Word_Prediction(text, n=3):
    prediction_list = []
    if text == "":
        for i in range(n):
            prediction_list.append(["", ""])
        return prediction_list
    text = text_db +" "+ text
    text = re.sub('\s+', ' ', re.sub('\W', ' ', text))
    # print(text)
    list_text_pd = underthesea.word_tokenize(text)[:-1]
    if text[-1] == " ":
        text_n = text[-PREDICTED_LENGTH*9:].split()[-PREDICTED_LENGTH:]
        text_n[-1] = text_n[-1]+" "
    else:
        text_n = text[-PREDICTED_LENGTH*9:].split()[-PREDICTED_LENGTH:]
    len_list_text_pd = len(list_text_pd)-1
    while len(text_n) > 0:
        text = " ".join(text_n)
        for ind, text_p in enumerate(list_text_pd):
            if text.strip() == text_p:
                if ind < len_list_text_pd:
                    prediction = list_text_pd[ind+1]
                    if text[-1] == " ":
                        prediction_op = [prediction, prediction]
                    else:
                        prediction_op = [prediction, " "+prediction]
                    prediction_list.append(prediction_op)
            elif text in text_p:
                if text_p.startswith(text):
                    prediction = text_p.replace(text, "", 1)
                    prediction_op = [text_p, prediction]
                    prediction_list.append(prediction_op)
        prediction_list.sort(key=lambda s: len(s[0]))
        len_prediction_list = len(prediction_list) >= n
        for x in prediction_list:
            if len(x[0].split()) >= PREDICTED_LENGTH and len_prediction_list >= n:
                prediction_list.remove(x)
        if len(prediction_list) >= n:
            return prediction_list[0:n]
        text_n.pop(0)
    for i in range(n-len(prediction_list)):
        prediction_list.append(["", ""])
    return prediction_list


def predict_next_word_in_view(text, idx=5):
    list_at = predict_next_word(text, idx)
    list_af = from_text_Next_Word_Prediction(text, 1)
    if list_af[0][0] != "":
        list_at = [list_af[0]] + list_at
    detra = []
    detro = []
    for x in list_at:
        if (not x[0] in detra) or x[0] == "":
            detro.append(x)
            detra.append(x[0])
    if detra.count("") == idx:
        return None
    list_at = detro[0:idx-1]
    for i in range(idx-len(list_at)):
        list_at.append(["", ""])
    return list_at


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
